import { Plugin, App, TFile } from "obsidian";

interface Settings {
  settings: string;
  withComment: boolean;
};

const DEFAULT_SETTINGS: Settings = {
  settings: 'default',
  withComment: false,
};

// Used to identify blocks of tags created by the plugin
const DELIMETER = "\u200C\u2063";

type TagMap = {
  tag: string,
  tFile: TFile,
};

export default class AutoTagNestedDirectories extends Plugin {
  settings: Settings;

  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }

  async saveSettings() {
    await this.saveData(this.settings);
  }

  /**
   * Ensure tags match the string requirements for a tag in obsidian markdown
   * @param preTags
   * @returns
   */
  formatTags(preTags: string[]): string[] {
    return preTags.map((tag) : string => {
      return tag.toLocaleLowerCase()
        .replace('&', 'and')
        .replace('%', 'mod')
        .replace('$', 'usd')
        .replace('Â£', 'gbp')
        .replace('#', 'pound')
        .replace(/[\W_]+/g, ' ')
        .replace(/\s+/g, '-');
    });
  }

  /**
   * Create the string to be inserted into a markdown file containing tags
   * @param tags
   * @returns
   */
  createNestedTagString(tags: string[]): string {
    return tags
      .map((tag) => `#${tag}`)
      .join(' ');
  }

  /**
   * Determine list of tags we should set based on parent dir tree
   * @param file
   * @returns
   */
  extractUpperDirectories(file: TFile): string[] {
    return file.path.split('/').slice(0, -1);
  }

  /**
   * Get an array containing a map of TFile objects to the tag strings
   * we should write to them
   * @returns
   */
  async mapNestedTagsFromFilePaths(): Promise<TagMap[]> {
    const markdownFiles = await this.app.vault.getMarkdownFiles();
    const tagMap = markdownFiles.map((mdFile) => {
      return {
        tag: this.createNestedTagString(
          this.formatTags(
            this.extractUpperDirectories(mdFile)
          )
        ),
        tFile: mdFile,
      };
    });

    return tagMap;
  }

  /**
   * Given a map of tags to their files, trigger the write operations
   * for each
   * @param entries
   */
  async writeMappedTags(entries: TagMap[]): Promise<void> {
    entries.forEach(entry => {
      this.writeNestedTagToFile(entry.tag, entry.tFile);
    });
  }

  /**
   * Create the string used appended to the tags to show that this is auto generated
   * content
   * @param counter
   * @returns
   */
  createAutoGeneratedComment(counter: Number = 0): string {
    return `// auto generated |${counter}|`;
  }

  /**
   * Check if a given string matches the expected format for a auto-generated
   * comment
   * @param comment
   * @returns
   */
  isValidAutoGeneratedComment(comment: string): boolean {
    return comment.match(/\/\/ auto generated \|\d+\|$/) !== null;
  }

  /**
   * Build the block of text to be inserted. Should contain the tag details
   * and optionally a comment specifying that the content is auto-generated.
   * @param tag
   * @returns
   */
  constructTagBlock(tag: string): string {
    const comment = this.createAutoGeneratedComment();
    let block = `${DELIMETER} ${tag} ${DELIMETER}`;
    if (this.settings.withComment) {
      block += `${comment}${DELIMETER}`;
    }
    return block;
  }

  /**
   * Check if some text contains an existing auto tag which matches
   * the expected format
   * @param text
   * @returns
   */
  async hasExistingTagBlock(text: string): Promise<boolean> {
    const contentParts = text.split(DELIMETER).filter((part) => {
      return !part.match(/^\n+$/);
    });
    const count = contentParts.length;
    if (count < 3) {
      return false;
    } else {
      const matchData = contentParts[1].match(/\#[\w\-]+/);
      if (!matchData) {
        return false;
      } else {
        return true;
      }
    }
  }

  /**
   * Write a new tag to the given TFile. Will either prepend or replace existing,
   * depending on presence of existing tag
   * @param tag
   * @param file
   */
  async writeNestedTagToFile(tag: string, file: TFile): Promise<void> {
    const currentContent = await this.app.vault.read(file);
    const tagBlock = this.constructTagBlock(tag);
    const locatedExistingTagBlock = await this.hasExistingTagBlock(currentContent);
    if (!locatedExistingTagBlock) {
      await this.prependTag(tagBlock, currentContent, file);
    } else {
      await this.replaceTag(tagBlock, currentContent, file);
    }
  }

  /**
   * Prepend Nested Tag string to front of file. Warning: This can be quite intesive
   * for very large files as it involved copying all content.
   * @param tag
   * @param currentContent
   * @param file
   */
  async prependTag(tag: string, currentContent: string, file: TFile): Promise<void> {
    await this.app.vault.modify(file, `${tag}\n\n${currentContent}`);
  }

  /**
   * Replace existing tag-like structure with new tag
   * @param tag
   * @param currentText
   * @param file
   */
  async replaceTag(tag: string, currentText: string, file: TFile): Promise<void> {
    const parts = currentText.split(DELIMETER).filter((part) => {
      return !part.match(/^\n+$/);
    });

    // modify main tag
    parts[1] = tag.split(DELIMETER)[1];

    // try to update the auto generated counter
    if (this.isValidAutoGeneratedComment(parts[2])) {
      // if we have a comment but setting was since toggled off, set to ''
      if (!this.settings.withComment) {
        parts[2] = '';
      } else {
        const commentParts = parts[2].split(/[\|\|]/);
        if (commentParts.length === 3) {
          // incrementer from comment - show how many times we've updated it
          let currentCounter = parseInt(commentParts[1], 10);
          currentCounter += 1;
          parts[2] = this.createAutoGeneratedComment(currentCounter);
        }
      }
    } else if (this.settings.withComment) {
      // add a comment if there isn't one currently but setting is on
      parts.splice(2, 0, this.createAutoGeneratedComment(0));
    }

    // join parts again and write
    await this.app.vault.modify(file, parts.join(DELIMETER));
  }

  /**
   * Remove tag from a file.
   * May have unforeseeable consequences if tags have been manually edited.
   * @param currentText
   * @param file
   */
  async removeTag(currentText: string, file: TFile): Promise<void> {
    if (await this.hasExistingTagBlock(currentText)) {
      const parts = currentText.split(DELIMETER).filter((part) => {
        return !part.match(/^\n+$/);
      });
      if (parts.length > 1) {
        // remove all inner parts that belong to the tag
        const contentToWrite = parts[0] + parts[parts.length - 1].trimStart();
        await this.app.vault.modify(file, contentToWrite);
      }
    }
  }

  async onload(): Promise<void> {
    await this.loadSettings();
    // const tagMap = await this.mapNestedTagsFromFilePaths();

    // tagMap.forEach((entry) => {
    //   this.writeNestedTagToFile(entry.tag, entry.tFile);
    // });
  }
};
